<!DOCTYPE html>
<html>
<head>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
<script src="dist/asciimath2tex.umd.js"></script>
<script src='dist/md_asciimath_like.js'></script>
<link rel="stylesheet" href="dist/style.css">
<link rel="shortcut icon" href="img/books.ico" />

	
<title>Haskell</title>
</head>
<body>


[NAVBAR Главная :: index.html, SQL :: sql_page.html]

# О Haskell, корохотенько

![https://pbs.twimg.com/media/EhiZqnbXcAIr4EE.jpg](intro)


Исполнить код на haskell можно с помощью [https://downloads.haskell.org/~platform/2014.2.0.0/](платформы).


Там есть

- компилятор (ghc)

- профилятор (hp2ps)

- repl (ghci)

- генератор документации (haddock)

- менеджер БД об установленных пакетах (ghc-pkg)

- сборщик статистики о коде (hpc)

- инструмент для спайки кода на haskell и C (hsc2hs)

- и запускаторы компилятора и интерпретатора (runghc, runhaskell)


В repl приглашение `Prelude> ` значит, что уже сразу подключен модуль `Prelude`.


Можно поменять строку приглашения `:set prompt "жопа> "`,
или повводить выражения `33+3*3`, `"ABC"++"DEFG"`.


Из текстовых редакторов на шindows доступны [https://notepad-plus-plus.org/downloads/](notepad++), если не хочется страдать, и
[http://mirror.tochlab.net/pub/gnu/emacs/windows/emacs-27](emacs)
с расширением [hs_spacemacs.html](spacemacs), если страдать хочется.


В случае с notepad++ можно нажав `F5` привязять к горячим клавишам комманду:

```
cmd /k cd /d $(CURRENT_DIRECTORY) && ghc -o a $(FULL_CURRENT_PATH) && $(CURRENT_DIRECTORY)/a && exit

```
которая позволит без труда строить и запускать скрипт.



## Hello, world

```
module Main where -- все программы начинают исполняться с действия main из модуля Main

import System.Environment -- внутри модуля можно подключать ещё модули (этот нужен для работы с консолью)

main :: IO () -- через символ :: указан тип переменной.
              -- тип IO () значит, что main - это действие (монада) ввода-вывода, которая возвращает пустоту

main = do                    -- Так начинается список действий, который сам по себе тоже действие.
    putStrLn "Hallo, world!" -- Первое наше действие это то, что вернёт функция putStrLn в обмен на строку ( она вернёт IO (), если что )
    putStrLn "\nPress ENTER to exit process ..."
    line <- getLine          -- Оператор <- забирает данные String из действия getLine :: IO String, кладёт их в line :: String,
                             -- а потом, скадывает в список действий пустое действие IO () из которого строку уже достали.
    return ()                -- Функция return создаёт любое действие (монаду), которую от неё потребуют.
                             -- Тут потребовали IO (), чтобы положить в список действий.

```

Монадный тип `IO` тут по сути выступает как контейнер для перевозки всякой фигни из консоли в локальную переменную
и для подтверждения, что консоль приняла всякую фигню от нас.


Вообще, блок `do` со списком действий это [https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D1%81%D0%B0%D1%85%D0%B0%D1%80#:~:text=%D0%A1%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9%20%D1%81%D0%B0%D1%85%D0%B0%D1%80%20(%D0%B0%D0%BD%D0%B3%D0%BB.,%D1%8F%D0%B7%D1%8B%D0%BA%D0%B0%20%D0%B1%D0%BE%D0%BB%D0%B5%D0%B5%20%D1%83%D0%B4%D0%BE%D0%B1%D0%BD%D1%8B%D0%BC%20%D0%B4%D0%BB%D1%8F%20%D1%87%D0%B5%D0%BB%D0%BE%D0%B2%D0%B5%D0%BA%D0%B0.](сахар)
над оператором перечисления действий [https://www.haskell.org/onlinereport/standard-prelude.html#$tMonad](`>>`).
А оператор `<-`, доступный только в блоке `do`, это сахар над оператором бесшовного перекладывания данных из *контейнера* с данными в функцию в обмен на уже пустой *контейнер* [https://www.haskell.org/onlinereport/standard-prelude.html#$tMonad](`>>=`).


Все действия в блоке `do` должны совпадать по монадному типу (по типу действия), и только последнее действие в блоке должно полностью совпадать с типом составного действия, частью которого она является.


## Hello, sceheme за 48 часов!

![https://sayingimages.com/wp-content/uploads/i-have-no-idea-what-im-doing-act-cute-meme.jpg](write scheme by yourself in 48 hours)

В haskell есть удобный инструмент парсинга -- [https://hackernoon.com/arcsecond-parsing-in-javascript-made-easy-af1894bdcec9](комбинатор парсеров).
Куча маленьких парсеров есть в модуле `Text.ParserCombiners.Parsec` ( через точку пишутся папки AKA путь к модулю ).

```
import Text.ParserCombiners.Parsec

symbol :: Parser Char
symbol = oneOf "!*+-/:<=>?@^_~#$%&|" -- хоба!
                                     -- собрали своё действие парсинга,
                                     -- которое где-то в своих недрах
                                     -- делает return какого-то Char-а

```

Действие монадного типа Parser, может быть исполнено функцией [http://hackage.haskell.org/package/parsec-3.1.6/docs/Text-Parsec-Prim.html#v:parse](`parse`),
которая возвращает результат алгебраического типа [https://www.haskell.org/onlinereport/standard-prelude.html#$tEither](`Either`), который либо `Left`, то есть ошибка, либо `Right`, то есть данные.

Алгебраический тип работает так:

```
-- вот он сам
data MyAlgType type1 type2 = Constructor1 type1
                           | Constructor2 type2

-- вот сконструировали переменную моего алгебраического типа
myVariable :: MyAlgType Int String
myVariable = Constructor2 "Oh, hi!"  -- могли бы ещё сконструировать так Constructor1 42


-- стрелка значит, что это функция
myAlgTypeToString :: MyAlgType Int String -> String

-- с помощью  конструкции case .. of перечисляем что делать
-- в случае с совпадением x-а с каким-нибудь шаблоном
myAlgTypeToString x = case x of       -- два плюса тут - это оператор конкатенации строк
    Constructor1 someNumber -> "here is a number " ++ (show someNumber)
    Constructor2 someString -> someString

main = do -- доллар значит, опставь открывающую скобку
    --   тут v        , а в конце строки добавь закрывающую скобку
    putStrLn $ myAlgTypeToString myVariable

    putStrLn "\nPress ENTER to exit process ..."
    line <- getLine
    return ()

```

Попробуем распарсить символ во входной строке

```
readExpr :: String -> String

-- у parse аргументы такие:
--      парсер которым нужно парсить, название потока, входная строка
readExpr input = case parse   symbol      "lisp"           input    of
    Left error  -> "No match: " ++ show error
    Right value -> "Found value"


```

Теперь спрячем в подключённой библиотеке функцию `spaces`,
потому что хотим потребовать хотя бы один whitespace символ.

Мы напишем свой `spaces`, используя функцию [http://hackage.haskell.org/package/base-4.7.0.1/docs/Text-ParserCombinators-ReadP.html#v:skipMany1](skipMany1)
и действие [https://hackage.haskell.org/package/parsec-3.1.14.0/docs/Text-Parsec-Char.html#v:space](space).

```
import Text.ParsingCombiners.Parsec hiding (spaces)

spaces :: Parser ()
spaces = skipMany1 space

```

А теперь впишем её в функцию `parseExpr`

```
readExpr input = case parse (spaces >> symbol) "lisp" input of
    Left error -> "No match: " ++ show error
    Right value -> "Found value"

```

Теперь определим алгебраический тип для разных видов нод в [https://ru.wikipedia.org/wiki/%D0%90%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BD%D0%BE%D0%B5_%D1%81%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE](AST) программы на lisp

```
data LispVal = Atom String
             | List [LispVal]                 -- это правильный список [one, two, three, four, five]
             | DottedList [LispVal] LispVal   -- это неправельный список [one, [two, [three, [four, [five, []]]]]]
             | Number Integer
             | String String              -- наш String и системный String находятся в разных пространствах имён, а потому могут одинаково называться
             | Bool Bool                  -- тут то же самое


```

Теперь соберём парсеры для всех этих конструкторов AKA нод

```
parseString :: Parser LispVal
parseString = do
    char '"'                -- пропарсили открывающий символ
    x <- many (noneOf "\"") -- достали из контейнера список символов (строку), которые не '"'
    char '"'                -- пропарсили закрывающий символ
    return $ String x       -- сконструировали и упаковали ноду


parseAtom :: Parser LispVal
parseAtom = do                   -- оператор выбора парсера <|> определён в Parsec и значит, что результат будет взят у первого сработавшего парсера
    first <- letter <|> symbol                 -- вначале это либо буква, либо символ
    rest <- many (letter <|> digit <|> symbol) -- оставшаяся часть это список из букв, цифр и символов
    let atom = first : rest                    -- оператор : это конструктор списка. Он берёт эллемент и список, а возвращает новый список, начинающийся с заданного эллемента.
    return $ case atom of        -- снова сконструировали и упаковали
               "#t" -> Bool True
               "#f" -> Bool False
                _   -> Atom atom


parseNumber :: Parser LispVal
parseNumber = liftM (Number . read) $ many1 digit

```



</body>
</html>
