<!DOCTYPE html>
<html>
<head>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
<script src="dist/asciimath2tex.umd.js"></script>
<script src='dist/md_asciimath_like.js'></script>
<link rel="stylesheet" href="dist/style.css">

	
<title>SQL</title>
</head>
<body>


[NAVBAR Главная :: index.html]

# Об SQL, корохотенько

![https://kulturologia.ru/files/u23581/235811589.jpg](intro)


SQL структурированный язык запросов к базам данных.


Самих запросов бывает 4 типа:

- объявление `create`, `drop`, `alert`

- модификация `insert`, `update`, `delete`, `select`

- установка уровня доступа `grant`, `revoke`

- и команды системы контроля версий `commit`, `rollback`



В базу данных можно класть таблицы, в таблицах есть столбцы,
в столбцах есть данные заданного типа,
которые подходят по заданным ограничениям.


Перед тем как данные в базу собирать, её проектируют

# ER диаграма

Вначале рисуется диаграма отношения сущностей



![https://d3n817fwly711g.cloudfront.net/uploads/2012/03/ER-Diagram-Example.jpeg](ER диаграма)

Вот сущность *Писатель* имеет связь *Создать* с сущностью *Новелла*.





![https://d3n817fwly711g.cloudfront.net/blog/wp-content/uploads/2012/03/Attributes-ER-Diagrams.jpeg](ещё ER диаграма)

Вот сущность *Покупатель* имеет аттрибуты *Имя*, *Адрес*, *Id*-шник.


Атрибут, особенный для отдельной реальзации сущности, называется **ключом**
и на таких диаграмах он должен подчёркиваться,
а тут **сурогатный** (в реальной жизни не существующий) **ключ** *Id* нифига не подчёркнут.

Ну не подчёркнут и не подчёркнут )



Ещё **ключ** бывает **составной**, то есть составленный из нескольких атрибутов. Но об этом потом.




# Перегон диаграм в таблицы

Для каждой сущности должна создаваться таблица.

Там каждая строка -- отдельная реализация сущности, а столбец -- это атрибут.


Со связями замороченнее.

- Если связь 1:1, то можно(нужно) хранить сущности в одной таблице.

- Если связь 1:N, то в таблице сущностей, которых много, указывается ключ той сущности, которая одна.

К примеру, много *Покупателей* *Любят* один *Товар*,

т.е. [*Товар*]--<Любит>-⋲[*Покупатель*].

Значит нужно каждому *Покупателю* ключ его любимого *Товара* вписать.


- Если связь N:N, то нужны 2 таблицы для сущностей и 1 для связи.



Вот хороший [https://sqliteonline.com/](online эмулятор) БД. Там можно(нужно) сразу попробовать всё.


# Объявление

## create

Можно создать базу данных и сразу дописать в неё всяких настроек

```
create database Test
    datafile 'test_system' -- где хранить БД
    size 20M               -- начальный размер БД
    -- и так далее --
;

```

Потом, в БД создаётся таблица

```
create table MyTable(

	 -- это тот самый ключ, о котором шла речь ранее. Он может быть только один.
	Id integer primary key,

 	-- NOT NULL значит, что в столбце не может быть пустых ячеек
	StringWithFixedSize char(10) NOT NULL,

	-- это то же что и строка выше, но строки могут быть короче 250 символов и дополняться пробелами автоматически не будут.
	SomeText varchar(250),

	-- это число с фиксированной точкой (всего 2 символа после запятой)
	NumWithFixedPoint NUMERIC(30,2),

	-- можно требовать чтобы данные были взяты из столбца другой таблицы
	SomeDate Date NOT NULL References AnotherTable(AttribOfAnotherTable)

	-- можно потребовать, чтобы данные в столбце не повторялись
	Skill char(20) NOT NULL UNIQUE,

	-- можно проверять данные сравнениями
	Cost integer CHECK(Cost > 0),

	-- можно потребовать уникальность комбинации
	Unique(Id, NumWithFloatingPoint),

	-- так же выглядит составной ключ
	-- primary key(Id, Cost)

);

```

## drop table

```
-- так удаляется
drop table MyTable


```


## alter table


Если мы хотим что-то сделать со столбцами, то тут то же самое.

```
-- они либо пересоздаются (модифицируются)
alter table MyTable
alter column Cost type NUMERIC(42,2) NOT NULL
;

-- либо создаются
alter table MyTable
add NewColumn varchar(15) NOT NULL
;

-- либо удаляются
alter table MyTable
drop column NewColumn
;


```


# Модификация

## insert into

```
-- просто пишется куда и что нужно вставить

insert into MyTable values(
	8,
	'Фалафель',
	'Сухой прошлогодний фалафель, но вам и этого достаточно',
	3.14,
	'2021-04-30',
	'Жесть',
	2200
);


```

## delete from

```
-- просто пишется откуда и что именно нужно удалить
delete from MyTable where Id=8;


```

## update

Эта команда по форме похожа на цикл `do {} while ()` из императивных языков.

Мы просто единообразно заполняем поля в строках, подходящих по фильтру.

Если фильтра нет \(=>\) подходит всё.

```
update MyTable
set StringWtihFixedSize = 'unknown', SomeText = '...'
where Cost < 10
;

```


## select

Эта команда для поиска и вывода данных.


Писать запросы поиска, которые хорошо оптимизируются -- это [https://techrocks.ru/2018/03/27/how-to-write-better-sql-queries/](особый вид искусства).



```

-- Сперва пишутся столбцы, которые мы хотим.
-- Затем, из какой таблицы мы хотим их взять.
-- звезда, значит хотим все
select * from MyTable;


-- Тут хотим столбец со строкой, переименованный в Title, и столбец с Id
-- А ещё, пусть всё это будет отсортировано по убыванию Cost
select StringWithFixedSize Title, Id from MyTable order by Cost desc; -- без desc, будет по возростанию


-- Можно искать данные по нескольким таблицам.
-- Можно сортировать по нескольким столбцам, в порядке убывания приоритета.
-- Можно на лету считать и записывать результат в новый столбец
select Cost, Cost*100 as CostMultipiedBy100 from MyTable, YourTable order by Cost;


-- Можно вывести, к примеру, одни лишь уникальные данные
select distinct Cost from MyTable order by Cost desc;


-- можно фильтровать данные каким-нибудь сравнением
select distinct Cost, StringWithFixedSize from MyTable where Cost < 100;
select distinct Cost, StringWithFixedSize from MyTable where Cost < 100 AND NOT 50 < Cost AND SomeText IS NOT NULL;
select distinct Cost, StringWithFixedSize from MyTable where Cost < 100 AND Id IN (1, 2, 3);


-- Ещё в фильтрах есть урезанная версия регулярных выражений
select distinct Cost, StringWithFixedSize from MyTable where Cost < 100 AND StringWithFixedSize LIKE 'Сырок%'
;
-- '%' - любая последовательность символов любой длины.
-- '_' - один любой символ


-- ещё есть агрегирующие операторы возвращающие всего одну ячейку
select string_agg(StringWithFixedSize, ';'), sum(Cost), count(*), avg(Cost), min(Cost), max(Cost) from MyTable
;

-- А ещё можно сцепить две таблицы, согласно какому-нибудь правилу
select st.Name, res.Grade
from Students st           -- для каждой строки таблицы слева
inner join ExamResult res  -- берём строку из таблицы справа
on st.StudId = res.StudId  -- подходящуу по правилу
;


```

</body>
</html>
